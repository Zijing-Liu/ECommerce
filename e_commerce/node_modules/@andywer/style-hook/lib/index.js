"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useStyles = useStyles;
exports.useStyle = useStyle;
exports.useGlobalStyles = useGlobalStyles;
Object.defineProperty(exports, "ThemeContext", {
  enumerable: true,
  get: function get() {
    return _theming.ThemeContext;
  }
});

var _styleApi = require("@andywer/style-api");

var _react = require("react");

var _theming = require("theming");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function useStylesInternal(styles, inputs) {
  var cssInJs = (0, _react.useContext)(_styleApi.CssInJsContext);
  var theme = (0, _react.useContext)(_theming.ThemeContext) || {};

  if (!cssInJs) {
    throw new Error("No CSS-in-JS implementation found in context.");
  }

  if (!theme._id) {
    // Hacky! Just give every theme we see an ID, so we can tell them apart easily
    theme._id = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
  }

  var _useState = (0, _react.useState)(function () {
    return cssInJs.createSheet(styles, theme._id, theme, inputs);
  }),
      _useState2 = _slicedToArray(_useState, 1),
      sheet = _useState2[0];

  (0, _react.useMutationEffect)(function () {
    sheet.attach();
    return function () {
      return sheet.detach();
    };
  }, []); // Misusing useMemo here to synchronously sheet.update() only if styles or theme changed

  (0, _react.useMemo)(function () {
    if (sheet.attached) {
      sheet.update(styles, theme);
    }
  }, inputs ? [theme].concat(_toConsumableArray(inputs)) : [theme, Math.random()]);
  return sheet.getClassNames();
}

function transformIntoGlobalStyles(styles) {
  var transformed = {};

  var _arr2 = Object.keys(styles);

  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
    var key = _arr2[_i2];
    transformed["@global ".concat(key)] = styles[key];
  }

  return transformed;
}

function wrapStyleCallback(styleCallback, transformStyles) {
  // Don't just pass-through arbitrary arguments, since we check function.length in useStyles()
  if (styleCallback.length === 0) {
    return function () {
      return transformStyles(styleCallback());
    };
  } else if (styleCallback.length === 1) {
    return function (theme) {
      return transformStyles(styleCallback(theme));
    };
  } else if (styleCallback.length === 2) {
    return function (theme, props) {
      return transformStyles(styleCallback(theme, props));
    };
  } else {
    return function () {
      return transformStyles(styleCallback.apply(void 0, arguments));
    };
  }
}

function useStyles(styles) {
  var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return useStylesInternal(styles, inputs);
}

function useStyle(style) {
  var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return useStylesInternal({
    style: style
  }, inputs).style;
}

function useGlobalStyles(styles) {
  var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var transformedStyles = transformIntoGlobalStyles(styles);
  useStylesInternal(transformedStyles, inputs);
}